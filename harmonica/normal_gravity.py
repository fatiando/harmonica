"""
Gravity of ellipsoids models.
"""
import numpy as np
from .ellipsoid import get_ellipsoid


def normal_gravity(latitude, height):
    """
    Calculate normal gravity at any latitude and height.

    Computes the magnitude of the gradient of the gravity potential (gravitational + centrifugal)
    generated by a reference ellipsoid at the given latitude and height.
    ``height``.
    It makes use of the closed form expression of [LiGotze2001]_ and the
    current reference ellipsoid defined by :func:`harmonica.set_ellipsoid`.

    Parameters
    ----------
    latitude : float or numpy array
        The latitude where the normal gravity will be computed (in degrees)
    height : float or numpy array
        The ellipsoidal (geometric) height of computation point (in meters).
        (geometric) heights for geophysical purposes.

    Returns
    -------
    gamma : float or numpy array
        The computed normal gravity (in mGal).

    """
    ellipsoid = get_ellipsoid()
    ecc = ellipsoid.linear_eccentricity
    omega2 = ellipsoid.angular_velocity**2

    big_w, q_l, q_0, b_l, cosbeta_l2, sinbeta_l2 = _normal_grav_factors(
        ellipsoid, latitude, height)
    term1 = ellipsoid.geocentric_grav_const / (b_l**2 + ecc**2)
    term2 = 0.5 * sinbeta_l2 - 1 / 6
    term2 *= ellipsoid.semimajor_axis**2 * ecc * q_l * omega2 / \
        ((b_l**2 + ecc**2) * q_0)
    term3 = -cosbeta_l2 * b_l * omega2
    gamma = (term1 + term2 + term3) / big_w
    # Convert gamma from SI to mGal
    gamma *= 1e5
    return gamma


def _normal_grav_factors(ellipsoid, latitude, height):
    ecc = ellipsoid.linear_eccentricity
    semiminor = ellipsoid.semiminor_axis
    rl2, zl2 = _normal_grav_r_z(ellipsoid, latitude, height)
    big_d = (rl2 - zl2) / ecc**2
    big_r = (rl2 + zl2) / ecc**2
    cosbeta_l2 = 0.5 * (1 + big_r) - \
        np.sqrt(0.25 * (1 + big_r**2) - 0.5 * big_d)
    sinbeta_l2 = 1 - cosbeta_l2
    b_l = np.sqrt(rl2 + zl2 - ecc**2 * cosbeta_l2)
    q_0 = 0.5 * ((1 + 3 * (semiminor / ecc)**2) * np.arctan2(ecc, semiminor)
                 - 3 * semiminor / ecc)
    q_l = 3 * (1 + (b_l / ecc)**2) * (1 - b_l / ecc * np.arctan2(ecc, b_l)) - 1
    big_w = np.sqrt((b_l**2 + ecc**2 * sinbeta_l2) / (b_l**2 + ecc**2))
    return big_w, q_l, q_0, b_l, cosbeta_l2, sinbeta_l2


def _normal_grav_r_z(ellipsoid, latitude, height):
    semimajor = ellipsoid.semimajor_axis
    semiminor = ellipsoid.semiminor_axis
    lat = np.deg2rad(latitude)
    coslat, sinlat = np.cos(lat), np.sin(lat)
    beta = np.arctan2(semiminor * sinlat / coslat, semimajor)
    cosbeta, sinbeta = np.cos(beta), np.sin(beta)
    zl2 = (semiminor * sinbeta + height * sinlat)**2
    rl2 = (semimajor * cosbeta + height * coslat)**2
    return rl2, zl2
