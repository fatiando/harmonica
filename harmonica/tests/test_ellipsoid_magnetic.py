# Copyright (c) 2018 The Harmonica Developers.
# Distributed under the terms of the BSD 3-Clause License.
# SPDX-License-Identifier: BSD-3-Clause
#
# This code is part of the Fatiando a Terra project (https://www.fatiando.org)
#
import re
from copy import copy

import numpy as np
import pytest
import verde as vd
from scipy.constants import mu_0

import harmonica as hm

from .._forward.create_ellipsoid import (
    OblateEllipsoid,
    ProlateEllipsoid,
    TriaxialEllipsoid,
)
from .._forward.ellipsoid_magnetics import (
    _demag_tensor_oblate_internal,
    _demag_tensor_prolate_internal,
    _demag_tensor_triaxial_internal,
    ellipsoid_magnetics,
    get_magnetisation,
)
from .._forward.utils_ellipsoids import get_rotation_matrix


def sphere_magnetic(coordinates, radius, center, magnetization):
    """
    Compute the magnetic field generated by a sphere with uniform magnetization.

    The field inside the sphere is uniform. Outside the sphere it's equivalent
    to the dipole field.

    Parameters
    ----------
    coordinates : tuple of floats or arrays
        Coordinates of the observation points in the following order:
        easting, northing, upward.
    radius : float
        Radius of the sphere.
    center : tuple of floats
        Coordinates of the center of the sphere in the same order as the
        ``coordinates``.
    magnetization : tuple of floats
        Magnetization vector of the sphere.

    Returns
    -------
    be, bn, bu : arrays
        Three components of the magnetic field on the observation points in nT.
    """
    # Ravel the coordinates into 1d arrays
    cast = np.broadcast(*coordinates)
    easting, northing, upward = tuple(np.asarray(c).ravel() for c in coordinates)

    # Get the coordinates of the observation points in a coordinate system
    # located in the center of the sphere
    x, y, z = (easting - center[0], northing - center[1], upward - center[2])

    # Allocate arrays for the resulting magnetic field
    be, bn, bu = tuple(np.zeros(cast.size) for _ in range(3))

    # Compute the internal magnetic field in nT.
    magnetization = np.asarray(magnetization)
    inside = (x**2 + y**2 + z**2) <= radius**2
    be[inside] += 2 / 3 * mu_0 * magnetization[0] * 1e9
    bn[inside] += 2 / 3 * mu_0 * magnetization[1] * 1e9
    bu[inside] += 2 / 3 * mu_0 * magnetization[2] * 1e9

    # Compute the external magnetic field (a dipole field) in nT.
    # Get the magnetic moment of the equivalent dipole
    mag_moment = 4 / 3 * np.pi * radius**3 * magnetization
    be_out, bn_out, bu_out = hm.dipole_magnetic(
        (easting[~inside], northing[~inside], upward[~inside]),
        center,
        mag_moment,
        field="b",
    )
    be[~inside] = be_out
    bn[~inside] = bn_out
    bu[~inside] = bu_out

    be, bn, bu = tuple(b.reshape(cast.shape) for b in (be, bn, bu))
    return be, bn, bu


def get_sphere_magnetization(susceptibility, external_field):
    """
    Compute sphere's induced magnetization.

    Parameters
    ----------
    susceptibility : float or (3, 3) array
        Magnetic susceptibility of the sphere as a scalar or a tensor.
    external_field : tuple
        The uniform magnetic field B as a tuple with values of
        (magnitude, inclination, declination). The magnitude should be in nT.

    Returns
    -------
    magnetization : tuple
        Tuple with components of the magnetization vector in A/m.
    """
    # Get external field components
    b0_field = np.array(hm.magnetic_angles_to_vec(*external_field))
    h0_field = b0_field / mu_0 * 1e-9  # convert to T

    # Compute magnetization of the sphere accounting for demagnetization effect.
    if not isinstance(susceptibility, np.ndarray):
        susceptibility = susceptibility * np.identity(3)
    inv = np.linalg.inv(np.identity(3) + 1 / 3 * susceptibility)
    magnetization = susceptibility @ inv @ h0_field
    return magnetization


@pytest.mark.parametrize(
    "ellipsoid",
    [
        ProlateEllipsoid(a=60, b=59.99, yaw=0, pitch=0, centre=(0, 0, 0)),
        TriaxialEllipsoid(
            a=60, b=59.999, c=59.998, yaw=0, pitch=0, roll=0, centre=(0, 0, 0)
        ),
        OblateEllipsoid(a=59.99, b=60, yaw=0, pitch=0, centre=(0, 0, 0)),
    ],
)
def test_likeness_to_sphere(ellipsoid):
    """Using a, b, c as almost equal, compare how the close the ellipsoids
    match the dipole-sphere magnetic approximation for low susceptibilities.
    At higher susceptibilities, the self-demag will make the ellipsoid
    deviate."""

    # create field
    k_values = [0.01, 0.001, 0.0001]
    external_field = (55_000, 0.0, 90.0)
    b0 = np.array(hm.magnetic_angles_to_vec(*external_field))
    h0_am = np.array(b0 * 1e-9 / mu_0)
    magnetizations = [k * h0_am for k in k_values]

    # create coords
    easting = np.linspace(0, 2 * 60, 50)
    northing, upward = np.zeros_like(easting), np.zeros_like(easting)
    coordinates = tuple(np.atleast_2d(c) for c in (easting, northing, upward))

    for k, magnetization in zip(k_values, magnetizations, strict=True):
        be, bn, bu = ellipsoid_magnetics(
            coordinates, ellipsoid, k, external_field, field="b"
        )
        be_sph, bn_sph, bu_sph = sphere_magnetic(
            coordinates, radius=60, center=(0, 0, 0), magnetization=magnetization
        )

        # test similarity
        rtol = 1e-2
        np.testing.assert_allclose(be_sph, be, rtol=rtol)
        np.testing.assert_allclose(bn_sph, bn, rtol=rtol)
        np.testing.assert_allclose(bu_sph, bu, rtol=rtol)


def test_euler_returns():
    """Check the euler returns are exact"""
    r0 = get_rotation_matrix(0, 0, 0)
    r360 = get_rotation_matrix(360, 0, 0)
    assert np.allclose(r0, r360)


def test_magnetic_symmetry():
    """
    Check the symmetry of magentic calculations at surfaces above and below
    the body.
    """
    a, b, c = (4, 3, 2)  # triaxial ellipsoid
    yaw, pitch, roll = (0, 0, 0)
    external_field = (10_000, 0, 0)
    susceptibility = 0.1
    triaxial_example = TriaxialEllipsoid(a, b, c, yaw, pitch, roll, (0, 0, 0))
    triaxial_example2 = TriaxialEllipsoid(a, b, c, yaw, pitch, roll, (0, 0, 0))

    # define observation points (2D grid) at surface height (z axis,
    # 'Upward') = 5
    coordinates = vd.grid_coordinates(
        region=(-20, 20, -20, 20), spacing=0.5, extra_coords=5
    )
    coordinates2 = vd.grid_coordinates(
        region=(-20, 20, -20, 20), spacing=0.5, extra_coords=-5
    )

    be1, bn1, bu1 = ellipsoid_magnetics(
        coordinates,
        triaxial_example,
        susceptibility,
        external_field,
        field="b",
    )
    be2, bn2, bu2 = ellipsoid_magnetics(
        coordinates2,
        triaxial_example2,
        susceptibility,
        external_field,
        field="b",
    )

    np.testing.assert_allclose(np.abs(be1), np.flip(np.abs(be2)))
    np.testing.assert_allclose(np.abs(bn1), np.flip(np.abs(bn2)))
    np.testing.assert_allclose(np.abs(bu1), np.flip(np.abs(bu2)))


def test_flipped_h0():
    """
    Check that reversing the magentising field produces the same (reversed)
    field.
    """

    a, b = (2, 4)  # triaxial ellipsoid
    yaw, pitch = 0, 0

    external_field1 = np.array((55_000, 0.0, 90.0))
    external_field2 = -external_field1
    susceptibility = 0.1
    oblate_example = OblateEllipsoid(a, b, yaw, pitch, (0, 0, 0))

    # define observation points (2D grid) at surface height (z axis,
    # 'Upward') = 5
    coordinates = vd.grid_coordinates(
        region=(-20, 20, -20, 20), spacing=0.5, extra_coords=5
    )

    be1, bn1, bu1 = ellipsoid_magnetics(
        coordinates,
        oblate_example,
        susceptibility,
        external_field1,
        field="b",
    )
    be2, bn2, bu2 = ellipsoid_magnetics(
        coordinates,
        oblate_example,
        susceptibility,
        external_field2,
        field="b",
    )

    np.testing.assert_allclose(np.abs(be1), np.abs(be2))
    np.testing.assert_allclose(np.abs(bn1), np.abs(bn2))
    np.testing.assert_allclose(np.abs(bu1), np.abs(bu2))


def test_zero_susceptibility():
    """
    Test for the case of 0 susceptibility == inducing field.
    """

    a, b = 1, 2
    susceptibility = 0
    ellipsoid = OblateEllipsoid(a, b, yaw=0, pitch=0, centre=(0, 0, 0))
    coordinates = vd.grid_coordinates(
        region=(-10, 10, -10, 10), spacing=1.0, extra_coords=5
    )
    h0 = hm.magnetic_angles_to_vec(55_000, 0.0, 90.0)

    be, bn, bu = ellipsoid_magnetics(
        coordinates, ellipsoid, susceptibility, h0, field="b"
    )

    np.testing.assert_allclose(be[0], 0)
    np.testing.assert_allclose(bn[0], 0)
    np.testing.assert_allclose(bu[0], 0)


def test_zero_field():
    """
    Test that zero field produces zero anomalies.
    """

    a, b = 1, 2
    external_field = np.array([0, 0, 0])
    susceptibility = 0.01

    ellipsoid = OblateEllipsoid(a, b, yaw=0, pitch=0, centre=(0, 0, 0))
    coordinates = vd.grid_coordinates(
        region=(-10, 10, -10, 10), spacing=1.0, extra_coords=5
    )

    be, bn, bu = ellipsoid_magnetics(
        coordinates, ellipsoid, susceptibility, external_field, field="b"
    )

    np.testing.assert_allclose(be[0], 0)
    np.testing.assert_allclose(bn[0], 0)
    np.testing.assert_allclose(bu[0], 0)


def test_mag_ext_int_boundary():
    """
    Check the boundary between internal and external field calculations is
    consistent.
    """

    a, b = 50, 60
    external_field = (55_000, 0.0, 90.0)
    susceptibility = 0.01

    ellipsoid = OblateEllipsoid(a, b, yaw=0, pitch=0, centre=(0, 0, 0))

    e = np.array([49.99, 50.00])
    n = np.array([0.0, 0.0])
    u = np.array([0.0, 0.0])
    coordinates = (e, n, u)

    be, _, _ = ellipsoid_magnetics(
        coordinates, ellipsoid, susceptibility, external_field, field="b"
    )

    np.testing.assert_allclose(be[0], be[1], rtol=1e-7)


def test_mag_flipped_ellipsoid():
    """
    Check that rotating the ellipsoid in various ways maintains expected
    results.

    """
    a, b, c = (4, 3, 2)
    external_field = (10_000, 0, 0)
    susceptibility = 0.01

    triaxial_example = TriaxialEllipsoid(
        a, b, c, yaw=0, pitch=0, roll=0, centre=(0, 0, 0)
    )
    triaxial_example2 = TriaxialEllipsoid(
        a, b, c, yaw=180, pitch=180, roll=180, centre=(0, 0, 0)
    )

    # define observation points (2D grid) at surface height (z axis,
    # 'Upward') = 5
    x, y, z = vd.grid_coordinates(
        region=(-20, 20, -20, 20), spacing=0.5, extra_coords=5
    )

    # ignore internal field as this won't be 'flipped' in the same natr
    internal_mask = ((x**2) / (a**2) + (y**2) / (b**2) + (z**2) / (c**2)) < 1
    coordinates = tuple(c[internal_mask] for c in (x, y, z))

    be1, bn1, bu1 = ellipsoid_magnetics(
        coordinates,
        triaxial_example,
        susceptibility,
        external_field,
        field="b",
    )
    be2, bn2, bu2 = ellipsoid_magnetics(
        coordinates,
        triaxial_example2,
        susceptibility,
        external_field,
        field="b",
    )

    np.testing.assert_allclose(np.abs(be1), np.abs(be2))
    np.testing.assert_allclose(np.abs(bn1), np.abs(bn2))
    np.testing.assert_allclose(np.abs(bu1), np.abs(bu2))


def test_euler_rotation_symmetry_mag():
    """
    Check thoroughly that euler rotations (e.g. 180 or 360 rotations) produce
    the expected result.
    """

    a, b, c = 5, 4, 3
    external_field = (55_000, 0.0, 90.0)
    susceptibility = 0.01
    coordinates = x, y, z = vd.grid_coordinates(
        region=(-5, 5, -5, 5), spacing=1.0, extra_coords=5
    )
    internal_mask = ((x**2) / (a**2) + (y**2) / (b**2) + (z**2) / (c**2)) < 1
    coordinates = tuple(c[internal_mask] for c in (x, y, z))

    def check_rotation_equivalence(base_ellipsoid, rotated_ellipsoids):
        base_be, base_bn, base_bu = ellipsoid_magnetics(
            coordinates, base_ellipsoid, susceptibility, external_field
        )
        for rotated in rotated_ellipsoids:
            be, bn, bu = ellipsoid_magnetics(
                coordinates, rotated, susceptibility, external_field
            )
            np.testing.assert_allclose(np.abs(be), np.abs(base_be), rtol=1e-4)
            np.testing.assert_allclose(np.abs(bn), np.abs(base_bn), rtol=1e-4)
            np.testing.assert_allclose(np.abs(bu), np.abs(base_bu), rtol=1e-4)

    # triaxial cases
    base_tri = TriaxialEllipsoid(a, b, c, yaw=0, pitch=0, roll=0, centre=(0, 0, 0))
    tri_rotated = [
        TriaxialEllipsoid(a, b, c, yaw=360, pitch=0, roll=0, centre=(0, 0, 0)),
        TriaxialEllipsoid(a, b, c, yaw=0, pitch=180, roll=0, centre=(0, 0, 0)),
        TriaxialEllipsoid(a, b, c, yaw=0, pitch=360, roll=360, centre=(0, 0, 0)),
    ]
    check_rotation_equivalence(base_tri, tri_rotated)

    # prolate cases
    base_pro = ProlateEllipsoid(a, b, yaw=0, pitch=0, centre=(0, 0, 0))
    pro_rotated = [
        ProlateEllipsoid(a, b, yaw=360, pitch=0, centre=(0, 0, 0)),
        ProlateEllipsoid(a, b, yaw=0, pitch=180, centre=(0, 0, 0)),
    ]
    check_rotation_equivalence(base_pro, pro_rotated)

    # oblate cases
    base_obl = OblateEllipsoid(b, a, yaw=0, pitch=0, centre=(0, 0, 0))
    obl_rotated = [
        OblateEllipsoid(b, a, yaw=360, pitch=0, centre=(0, 0, 0)),
        OblateEllipsoid(b, a, yaw=0, pitch=180, centre=(0, 0, 0)),
    ]
    check_rotation_equivalence(base_obl, obl_rotated)


def test_internal_depol_equals_1():
    """Test that the internal depol tensor component sum equals 1"""

    onxx, onyy, onzz = _demag_tensor_oblate_internal(3, 5)
    np.testing.assert_allclose((onxx + onyy + onzz), 1)

    pnxx, pnyy, pnzz = _demag_tensor_prolate_internal(5, 3)
    np.testing.assert_allclose((pnxx + pnyy + pnzz), 1)

    tnxx, tnyy, tnzz = _demag_tensor_triaxial_internal(5, 4, 3)
    np.testing.assert_allclose((tnxx + tnyy + tnzz), 1)


class TestDemagnetizationEffects:
    """
    Test the ``get_magnetisation`` function.
    """

    @pytest.fixture(params=("oblate", "prolate", "triaxial"))
    def ellipsoid_semiaxes(self, request):
        ellipsoid_type = request.param
        match ellipsoid_type:
            case "oblate":
                a, b = 50.0, 60.0
                c = b
            case "prolate":
                a, b = 60.0, 50.0
                c = b
            case "triaxial":
                a, b, c = 70.0, 60.0, 50.0
            case _:
                raise ValueError()
        return a, b, c

    def test_demagnetization(self, ellipsoid_semiaxes):
        """
        Test demagnetization effects in ``get_magnetization``.

        The magnetization accounting with demagnetization should have a smaller
        magnitude than the magnetization without considering it.
        """
        h0_field = np.array([55_000.0, 10_000.0, -2_000.0])

        a, b, c = ellipsoid_semiaxes
        susceptibility = 0.5
        susceptibility_tensor = susceptibility * np.identity(3)

        # Compute magnetization considering demagnetization effect
        rem_mag = (0, 0, 0)
        magnetization = get_magnetisation(
            a, b, c, susceptibility_tensor, h0_field, rem_mag
        )

        # Compute magnetization without considering demagnetization effect
        magnetization_no_demag = susceptibility * h0_field

        # Check that the former is smaller than the latter
        assert (magnetization**2).sum() < (magnetization_no_demag**2).sum()


@pytest.mark.parametrize(
    ("ellipsoid_type", "a", "b", "c"),
    [
        ("oblate", 50.0, 60.0, 60.0),
        ("prolate", 60.0, 50.0, 50.0),
        ("triaxial", 70.0, 60.0, 50.0),
    ],
)
def test_internal_demagnetization_components(ellipsoid_type, a, b, c):
    r"""
    Test if demagnetization tensors inside the ellipsoids have all positive values.

    This guarantees that the code implements the appropriate sign convention for the
    demagnetization tensor :math:`\mathbf{N}`, defined as:

    .. math::

        \mathbf{H}(\mathbf{r}) = \mathbf{H}_0 - \mathbf{N}(\mathbf{r}) \mathbf{M}
    """
    match ellipsoid_type:
        case "oblate":
            n_components = _demag_tensor_oblate_internal(a, b)
        case "prolate":
            n_components = _demag_tensor_prolate_internal(a, b)
        case "triaxial":
            n_components = _demag_tensor_triaxial_internal(a, b, c)
        case _:
            raise ValueError()

    # check that all diagonal elements are positive
    assert all(n > 0 for n in n_components)


class TestMagnetizationVersusSphere:
    """
    Test if ellipsoid's magnetization approximates the one of the sphere.
    """

    @pytest.fixture
    def radius(self):
        """
        Sphere radius.
        """
        return 50.0

    @pytest.fixture(params=("oblate", "prolate", "triaxial"))
    def ellipsoid_semiaxes(self, radius, request):
        """
        Ellipsoid's semiaxes that approximate a sphere.
        """
        a = radius
        ellipsoid_type = request.param
        match ellipsoid_type:
            case "oblate":
                b = c = a + 1e-2
            case "prolate":
                b = c = a - 1e-2
            case "triaxial":
                b = a - 1e-3
                c = a - 1e-2
            case _:
                raise ValueError()
        return a, b, c

    def test_magnetization_vs_sphere(self, ellipsoid_semiaxes):
        """
        Test if ellipsoid's magnetization approximates the one of the sphere.
        """
        # Define moderately high susceptibility to account for demagnetization effects
        susceptibility = 0.5

        # Define arbitrary external field
        intensity, inclination, declination = 55_321, 70.2, -12.3
        b0_field = np.array(
            hm.magnetic_angles_to_vec(intensity, inclination, declination)
        )
        h0_field = b0_field / mu_0 * 1e-9  # convert to T

        # Compute magnetizations
        a, b, c = ellipsoid_semiaxes
        k_matrix = susceptibility * np.identity(3)
        rem_mag = (0, 0, 0)
        magnetization_ellipsoid = get_magnetisation(
            a, b, c, k_matrix, h0_field, rem_mag
        )
        magnetization_sphere = get_sphere_magnetization(
            susceptibility, (intensity, inclination, declination)
        )

        # Compare magnetization of the sphere vs magnetization of the ellipsoid
        rtol = 1e-4
        np.testing.assert_allclose(
            magnetization_ellipsoid, magnetization_sphere, rtol=rtol
        )


class TestMagneticFieldVersusSphere:
    """
    Test if magnetic field of ellipsoid approximates the one of the sphere.
    """

    # Sphere radius, center, and susceptibility.
    radius = 50.0
    center = (0, 0, 0)
    susceptibility = 0.5

    # Difference between ellipsoid's semiaxes.
    # It should be small compared to the sphere radius, so the ellipsoid approximates
    # a sphere.
    delta = 0.001

    # Define external field
    external_field = (55_123.0, 32.0, -28.9)

    @pytest.fixture(params=[0.0, 100.0], ids=["height=0", "height=100"])
    def coordinates(self, request):
        """Sample coordinates of observation points."""
        region = (-200, 200, -200, 200)
        shape = (151, 151)
        height = request.param
        coordinates = vd.grid_coordinates(region, shape=shape, extra_coords=height)
        return coordinates

    @pytest.fixture
    def sphere_magnetic_field(self, coordinates):
        """Magnetic field of sphere on observation points."""
        magnetization = get_sphere_magnetization(
            self.susceptibility, self.external_field
        )
        b_sphere = sphere_magnetic(coordinates, self.radius, self.center, magnetization)
        return b_sphere

    def get_ellipsoid(self, ellipsoid_type: str):
        """
        Return ellipsoid that approximates a sphere.

        Parameters
        ----------
        ellipsoid_type : {"oblate", "prolate", "triaxial"}
            Type of ellipsoid.

        Returns
        -------
        OblateEllipsoid, ProlateEllipsoid or TriaxialEllipsoid
        """
        yaw, pitch, roll = 0, 0, 0
        a = self.radius
        match ellipsoid_type:
            case "oblate":
                ellipsoid = OblateEllipsoid(
                    a=a,
                    b=a + self.delta,
                    yaw=yaw,
                    pitch=pitch,
                    centre=self.center,
                )
            case "prolate":
                ellipsoid = ProlateEllipsoid(
                    a=a,
                    b=a - self.delta,
                    yaw=yaw,
                    pitch=pitch,
                    centre=self.center,
                )
            case "triaxial":
                ellipsoid = TriaxialEllipsoid(
                    a=a,
                    b=a - self.delta,
                    c=a - 2 * self.delta,
                    yaw=yaw,
                    pitch=pitch,
                    roll=roll,
                    centre=self.center,
                )
            case _:
                raise ValueError()
        return ellipsoid

    @pytest.mark.parametrize("ellipsoid_type", ["oblate", "prolate", "triaxial"])
    def test_magnetic_field_vs_sphere(
        self, coordinates, sphere_magnetic_field, ellipsoid_type
    ):
        """
        Test magnetic field of ellipsoids against the one for a sphere.
        """
        b_e_sphere, b_n_sphere, b_u_sphere = sphere_magnetic_field
        ellipsoid = self.get_ellipsoid(ellipsoid_type)
        b_e, b_n, b_u = ellipsoid_magnetics(
            coordinates, ellipsoid, self.susceptibility, self.external_field, field="b"
        )
        maxabs = np.max([np.abs(b_e_sphere), np.abs(b_n_sphere), np.abs(b_u_sphere)])
        atol = maxabs * 0.01
        rtol = 1e-4
        np.testing.assert_allclose(b_e_sphere, b_e, atol=atol, rtol=rtol)
        np.testing.assert_allclose(b_n_sphere, b_n, atol=atol, rtol=rtol)
        np.testing.assert_allclose(b_u_sphere, b_u, atol=atol, rtol=rtol)


class TestSymmetryOnRotations:
    """
    Test symmetries in the magnetic field after rotations are applied.
    """

    def flip_ellipsoid(self, ellipsoid):
        """
        Flip ellipsoid 180 degrees keeping the same geometry.

        The rotation will make the ellipsoid to turn 180 degrees, so its geometry is
        preserved. The sign change in pitch and roll is required to ensure the symmetry.
        """
        ellipsoid.yaw += 180
        ellipsoid.pitch *= -1
        if isinstance(ellipsoid, TriaxialEllipsoid):
            ellipsoid.roll *= -1
        return ellipsoid

    @pytest.fixture(params=["oblate", "prolate", "triaxial"])
    def ellipsoid(self, request):
        """Sample ellipsoid."""
        ellipsoid_type = request.param
        # Generate original ellipsoid
        semimajor, semimiddle, semiminor = 57.2, 42.0, 21.2
        center = (0, 0, 0)
        yaw, pitch, roll = 62.3, 48.2, 14.9
        match ellipsoid_type:
            case "oblate":
                ellipsoid = OblateEllipsoid(
                    a=semiminor, b=semimajor, yaw=yaw, pitch=pitch, centre=center
                )
            case "prolate":
                ellipsoid = ProlateEllipsoid(
                    a=semimajor, b=semiminor, yaw=yaw, pitch=pitch, centre=center
                )
            case "triaxial":
                ellipsoid = TriaxialEllipsoid(
                    a=semimajor,
                    b=semimiddle,
                    c=semiminor,
                    yaw=yaw,
                    pitch=pitch,
                    roll=roll,
                    centre=center,
                )
            case _:
                raise ValueError()
        return ellipsoid

    @pytest.mark.parametrize("magnetization_type", ["induced", "remanent", "both"])
    def test_symmetry_when_flipping(self, ellipsoid, magnetization_type):
        """
        Test symmetry of magnetic field when flipping the ellipsoid.

        Rotate the ellipsoid so the geometry is preserved. The magnetic field generated
        by the ellipsoid should be the same as before the rotation.

        Since the remanent magnetization vector is defined in the global coordinate
        system, it won't rotate with the ellipsoid.
        """
        # Define observation points
        coordinates = vd.grid_coordinates(
            region=(-20, 20, -20, 20), spacing=0.5, extra_coords=5
        )

        # Generate a flipped ellipsoid
        ellipsoid_flipped = self.flip_ellipsoid(copy(ellipsoid))

        # Define physical properties
        external_field = (55_000, -71, 15)
        magnetization = (
            (400, 21, -8) if magnetization_type in ("remanent", "both") else (0, 0, 0)
        )
        susceptibility = 0.1 if magnetization_type in ("induced", "both") else 0.0

        # Compute magnetic fields
        b_field, b_field_flipped = tuple(
            ellipsoid_magnetics(
                coordinates,
                ell,
                susceptibilities=susceptibility,
                external_field=external_field,
                remnant_mag=magnetization,
            )
            for ell in (ellipsoid, ellipsoid_flipped)
        )

        # Check that the B field is the same for original and flipped ellipsoids
        for i in range(3):
            np.testing.assert_allclose(b_field[i], b_field_flipped[i])


class TestSusceptibilityTensor:
    """Test forward when susceptibility is a tensor."""

    def test_susceptibility_as_tensor(self):
        """Test forward model using anisotropic susceptibility."""
        coordinates = (0, 0, 0)
        ellipsoid = ProlateEllipsoid(
            a=40, b=15, yaw=170.2, pitch=71, centre=(15.0, 0.0, -40.0)
        )
        susceptibility = np.random.default_rng(seed=42).uniform(size=(3, 3))
        external_field = (55_000, 12, 74)

        # Check if no error is raised after using an anisotropic susceptibility
        ellipsoid_magnetics(
            coordinates, ellipsoid, susceptibility, external_field=external_field
        )

    def test_invalid_susceptibility_as_tensor(self):
        """Test error after invalid susceptibility tensor."""
        coordinates = (0, 0, 0)
        ellipsoid = ProlateEllipsoid(
            a=40, b=15, yaw=170.2, pitch=71, centre=(15.0, 0.0, -40.0)
        )
        external_field = (55_000, 12, 74)

        invalid_shape = (3, 4)
        susceptibility = np.random.default_rng(seed=42).uniform(size=invalid_shape)

        msg = re.escape("Susceptibility matrix must be 3x3")
        with pytest.raises(ValueError, match=msg):
            ellipsoid_magnetics(
                coordinates, ellipsoid, susceptibility, external_field=external_field
            )

    def test_invalid_susceptibility_type(self):
        """Test error after invalid susceptibility type."""

        class InvalidSus: ...

        coordinates = (0, 0, 0)
        ellipsoid = ProlateEllipsoid(
            a=40, b=15, yaw=170.2, pitch=71, centre=(15.0, 0.0, -40.0)
        )
        external_field = (55_000, 12, 74)
        susceptibility = InvalidSus()

        msg = re.escape("Unrecognized susceptibility type")
        with pytest.raises(TypeError, match=msg):
            ellipsoid_magnetics(
                coordinates, ellipsoid, susceptibility, external_field=external_field
            )


class TestMultipleEllipsoids:
    """
    Test forward function when passing multiple ellipsoids.
    """

    @pytest.fixture
    def coordinates(self):
        """Sample grid coordinates."""
        region = (-30, 30, -30, 30)
        coordinates = vd.grid_coordinates(
            region=region, shape=(21, 21), extra_coords=10
        )
        return coordinates

    @pytest.fixture
    def ellipsoids(self):
        """Sample ellipsoids."""
        ellipsoids = [
            OblateEllipsoid(
                a=20, b=60, yaw=30.2, pitch=-23, centre=(-10.0, 20.0, -10.0)
            ),
            ProlateEllipsoid(
                a=40, b=15, yaw=170.2, pitch=71, centre=(15.0, 0.0, -40.0)
            ),
            TriaxialEllipsoid(
                a=60,
                b=18,
                c=15,
                yaw=272.1,
                pitch=43,
                roll=98,
                centre=(0.0, 20.0, -30.0),
            ),
        ]
        return ellipsoids

    @pytest.fixture(params=["list", "array", "anisotropic"])
    def susceptibilities(self, request):
        """Sample susceptibilities."""
        susceptibilities = [0.1, 0.01, 0.05]
        if request.param == "array":
            susceptibilities = np.array(susceptibilities)
        elif request.param == "anisotropic":
            # Replace one value with a tensor
            sus_tensor = np.random.default_rng(seed=42).uniform(size=(3, 3))
            susceptibilities[-1] = sus_tensor
        return susceptibilities

    @pytest.fixture(params=["list", "array"])
    def remnant_mag(self, request):
        """Sample remanent magnetizations."""
        rem_magnetizations = [
            [1.0, 2.0, 3.0],
            [5.0, -1.0, -3.0],
            None,
        ]
        if request.param == "array":
            rem_magnetizations = [
                mr if mr is not None else [0, 0, 0] for mr in rem_magnetizations
            ]
            rem_magnetizations = np.array(rem_magnetizations)
        return rem_magnetizations

    def test_multiple_ellipsoids_susceptibilities(
        self, coordinates, ellipsoids, susceptibilities
    ):
        """
        Run forward function with multiple ellipsoids (only with susceptibilities).
        """
        # Define external field
        external_field = (55_000, -15, 65)

        # Compute magnetic field
        bx, by, bz = ellipsoid_magnetics(
            coordinates,
            ellipsoids,
            susceptibilities,
            external_field=external_field,
        )

        # Compute expected arrays
        bx_expected, by_expected, bz_expected = tuple(
            np.zeros_like(coordinates[0]) for _ in range(3)
        )
        for ellipsoid, susceptibility in zip(ellipsoids, susceptibilities, strict=True):
            bx_i, by_i, bz_i = ellipsoid_magnetics(
                coordinates,
                ellipsoid,
                susceptibility,
                external_field=external_field,
            )
            bx_expected += bx_i
            by_expected += by_i
            bz_expected += bz_i

        # Check if fields are the same
        np.testing.assert_allclose(bx, bx_expected)
        np.testing.assert_allclose(by, by_expected)
        np.testing.assert_allclose(bz, bz_expected)

    def test_multiple_ellipsoids_remanence(self, coordinates, ellipsoids, remnant_mag):
        """
        Run forward function with multiple ellipsoids with remanence.
        """
        # Physical properties of ellipsoids
        susceptibilities = [0.1, 0.01, 0.05]
        external_field = (55_000, -15, 65)

        # Compute magnetic field
        bx, by, bz = ellipsoid_magnetics(
            coordinates,
            ellipsoids,
            susceptibilities,
            external_field=external_field,
            remnant_mag=remnant_mag,
        )

        # Compute expected arrays
        bx_expected, by_expected, bz_expected = tuple(
            np.zeros_like(coordinates[0]) for _ in range(3)
        )
        for ellipsoid, susceptibility, rem in zip(
            ellipsoids, susceptibilities, remnant_mag, strict=True
        ):
            bx_i, by_i, bz_i = ellipsoid_magnetics(
                coordinates,
                ellipsoid,
                susceptibility,
                external_field=external_field,
                remnant_mag=rem,
            )
            bx_expected += bx_i
            by_expected += by_i
            bz_expected += bz_i

        # Check if fields are the same
        np.testing.assert_allclose(bx, bx_expected)
        np.testing.assert_allclose(by, by_expected)
        np.testing.assert_allclose(bz, bz_expected)


class TestInvalidInputs:
    """Test errors after passing invalid inputs."""

    @pytest.fixture
    def prolate_ellipsoid(self):
        ellipsoid = ProlateEllipsoid(
            a=40, b=15, yaw=170.2, pitch=71, centre=(15.0, 0.0, -40.0)
        )
        return ellipsoid

    @pytest.mark.parametrize(
        "susceptibilities",
        [[1.0, 2.0], [1.0, 2.0, 3.0, 4.0], []],
        ids=["2 elements", "4 elements", "0 elements"],
    )
    def test_invalid_susceptibilities(self, prolate_ellipsoid, susceptibilities):
        """Test error after susceptibilities with wrong number of elements."""
        ellipsoids = [prolate_ellipsoid for _ in range(3)]
        external_field = (55_000, 12, 41)
        coordinates = (0, 0, 0)
        msg = re.escape(
            f"Invalid susceptibilities with '{len(susceptibilities)}' elements. "
            "It must have the same number of elements as ellipsoids (3)."
        )
        with pytest.raises(ValueError, match=msg):
            ellipsoid_magnetics(
                coordinates, ellipsoids, susceptibilities, external_field=external_field
            )

    def test_invalid_remnant_mag_no_sequence(self, prolate_ellipsoid):
        """Test error after remanent magnetization type."""
        ellipsoids = [prolate_ellipsoid for _ in range(3)]
        susceptibilities = [0, 0, 0]
        external_field = (55_000, 12, 41)
        coordinates = (0, 0, 0)
        invalid_remnant_mag = 1.0
        msg = re.escape(
            f"Invalid 'remnant_mag' '{invalid_remnant_mag}' of "
            f"type {type(invalid_remnant_mag)}."
        )
        with pytest.raises(TypeError, match=msg):
            ellipsoid_magnetics(
                coordinates,
                ellipsoids,
                susceptibilities,
                external_field=external_field,
                remnant_mag=invalid_remnant_mag,
            )

    @pytest.mark.parametrize(
        "remnant_mag",
        [
            [1, 2, 3],
            [[1, 2, 3]],
            [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]],
            [],
        ],
        ids=["a vector", "1 element", "4 elements", "0 elements"],
    )
    def test_invalid_remnant_mag_wrong_elements(self, prolate_ellipsoid, remnant_mag):
        """Test error after remanent magnetization with wrong number of elements."""
        ellipsoids = [prolate_ellipsoid for _ in range(3)]
        susceptibilities = [0, 0, 0]
        external_field = (55_000.0, 12, 41)
        coordinates = (0, 0, 0)
        msg = (
            "Invalid \\'remnant_mag\\' with \\'[0-9]+\\' elements\\. "
            "It should be a list of arrays with three elements, with equal "
            f"amount of arrays as number of ellipsoids \\(\\'{len(ellipsoids)}\\'\\)."
        )
        with pytest.raises(ValueError, match=msg):
            ellipsoid_magnetics(
                coordinates,
                ellipsoids,
                susceptibilities,
                external_field=external_field,
                remnant_mag=remnant_mag,
            )

    @pytest.mark.parametrize(
        "remnant_mag",
        [
            [[1, 2], [1, 2]],
            [[1, 2, 3, 4], [1, 2, 3, 4]],
        ],
    )
    def test_invalid_remnant_mag_wrong_shape(self, prolate_ellipsoid, remnant_mag):
        """Test error after remanent magnetization with wrong number of elements."""
        ellipsoids = [prolate_ellipsoid for _ in range(2)]
        susceptibilities = [0, 0]
        external_field = (55_000.0, 12, 41)
        coordinates = (0, 0, 0)
        msg = (
            r"Invalid remanent magnetizations with shape \'\([0-9]+, [0-9]+\)\'. "
            + re.escape(f"It must have a shape of '({len(ellipsoids)}, 3)'.")
        )
        with pytest.raises(ValueError, match=msg):
            ellipsoid_magnetics(
                coordinates,
                ellipsoids,
                susceptibilities,
                external_field=external_field,
                remnant_mag=remnant_mag,
            )
