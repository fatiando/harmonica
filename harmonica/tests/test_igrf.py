# Copyright (c) 2018 The Harmonica Developers.
# Distributed under the terms of the BSD 3-Clause License.
# SPDX-License-Identifier: BSD-3-Clause
#
# This code is part of the Fatiando a Terra project (https://www.fatiando.org)
#
"""
Test the IGRF results against the ones calculated by the BGS.
"""
import datetime
import os

import numpy as np
import numpy.testing as npt
import pytest

from .._spherical_harmonics.igrf import (
    IGRF14,
    fetch_igrf14,
    interpolate_coefficients,
    load_igrf,
)

# IGRF values for the city of SÃ£o Paulo every 4 years on 1st of January.
# Elevation: 700.00000 km GPS. Latitude: -23.50000 degrees. Longitude:
# -43.70000 degrees. Columns are decimal year, B_east, B_north, B_down in nT.
# Generated by https://www.ngdc.noaa.gov/geomag/calculators/magcalc.shtml using
# IGRF14 coefficients.
IGRF_SAO_PAULO = np.array(
    [
        [1900.0, 18814.8, -2125.3, -5306.1],
        [1904.0, 18729.4, -2301.5, -5382.3],
        [1908.0, 18632.1, -2505.1, -5456.2],
        [1912.0, 18520.9, -2721.1, -5534.7],
        [1916.0, 18395.5, -2930.2, -5627.6],
        [1920.0, 18257.6, -3108.6, -5748.0],
        [1924.0, 18105.3, -3252.8, -5904.0],
        [1928.0, 17955.4, -3382.4, -6046.8],
        [1932.0, 17813.4, -3502.4, -6184.9],
        [1936.0, 17676.8, -3610.6, -6326.7],
        [1940.0, 17534.4, -3698.0, -6480.7],
        [1944.0, 17348.9, -3771.3, -6638.7],
        [1948.0, 17141.4, -3828.7, -6805.6],
        [1952.0, 16938.1, -3890.5, -6977.3],
        [1956.0, 16737.5, -3970.7, -7150.7],
        [1960.0, 16510.1, -4077.5, -7323.0],
        [1964.0, 16303.0, -4151.8, -7564.1],
        [1968.0, 16078.0, -4224.3, -7773.1],
        [1972.0, 15850.2, -4291.2, -7982.2],
        [1976.0, 15624.2, -4355.4, -8207.6],
        [1980.0, 15393.7, -4426.1, -8449.2],
        [1984.0, 15147.2, -4463.2, -8712.2],
        [1988.0, 14909.0, -4481.1, -8947.2],
        [1992.0, 14681.3, -4486.8, -9173.8],
        [1996.0, 14457.2, -4486.4, -9399.7],
        [2000.0, 14218.5, -4485.7, -9614.1],
        [2004.0, 13997.2, -4483.1, -9829.1],
        [2008.0, 13771.8, -4487.4, -10063.4],
        [2012.0, 13531.2, -4485.4, -10312.5],
        [2016.0, 13278.2, -4468.8, -10576.1],
        [2020.0, 13030.1, -4434.5, -10858.8],
        [2024.0, 12785.6, -4367.4, -11099.7],
    ]
)
# IGRF values for the city of Ulaanbaatar every 3 years on 1st of June.
# Elevation: 3000.00000 km GPS. Latitude: 47.90000 degrees. Longitude:
# 106.90000 degrees. Columns are decimal year, B_east, B_north, B_down in nT.
# Generated by https://www.ngdc.noaa.gov/geomag/calculators/magcalc.shtml using
# IGRF14 coefficients.
IGRF_ULAANBAATAR = np.array(
    [
        [1.9004137e03, 7.6708000e03, 1.2300000e02, 1.4357800e04],
        [1.9034137e03, 7.6617000e03, 1.1180000e02, 1.4365500e04],
        [1.9064137e03, 7.6491000e03, 9.8600000e01, 1.4370800e04],
        [1.9094137e03, 7.6327000e03, 8.3200000e01, 1.4373500e04],
        [1.9124137e03, 7.6112000e03, 6.0200000e01, 1.4371100e04],
        [1.9154137e03, 7.5885000e03, 3.5100000e01, 1.4366500e04],
        [1.9184137e03, 7.5666000e03, 8.9000000e00, 1.4355400e04],
        [1.9214137e03, 7.5480000e03, -1.5200000e01, 1.4346800e04],
        [1.9244137e03, 7.5329000e03, -3.7100000e01, 1.4340900e04],
        [1.9274137e03, 7.5223000e03, -5.6200000e01, 1.4339200e04],
        [1.9304137e03, 7.5136000e03, -7.4000000e01, 1.4339900e04],
        [1.9334137e03, 7.5103000e03, -8.7000000e01, 1.4349800e04],
        [1.9364137e03, 7.5108000e03, -9.9300000e01, 1.4364300e04],
        [1.9394137e03, 7.5158000e03, -1.1050000e02, 1.4384100e04],
        [1.9424137e03, 7.5236000e03, -1.1910000e02, 1.4419600e04],
        [1.9454137e03, 7.5322000e03, -1.2710000e02, 1.4457800e04],
        [1.9484137e03, 7.5411000e03, -1.3560000e02, 1.4487800e04],
        [1.9514137e03, 7.5504000e03, -1.4470000e02, 1.4511900e04],
        [1.9544137e03, 7.5603000e03, -1.5460000e02, 1.4529400e04],
        [1.9574137e03, 7.5650000e03, -1.6370000e02, 1.4535800e04],
        [1.9604137e03, 7.5689000e03, -1.7180000e02, 1.4538700e04],
        [1.9634137e03, 7.5753000e03, -1.7480000e02, 1.4536200e04],
        [1.9664137e03, 7.5770000e03, -1.7770000e02, 1.4527200e04],
        [1.9694137e03, 7.5733000e03, -1.8060000e02, 1.4510900e04],
        [1.9724137e03, 7.5671000e03, -1.8250000e02, 1.4494500e04],
        [1.9754137e03, 7.5600000e03, -1.8500000e02, 1.4481500e04],
        [1.9784137e03, 7.5499000e03, -1.9350000e02, 1.4489700e04],
        [1.9814137e03, 7.5336000e03, -2.0060000e02, 1.4498400e04],
        [1.9844137e03, 7.5103000e03, -2.0620000e02, 1.4507700e04],
        [1.9874137e03, 7.4872000e03, -2.0580000e02, 1.4524100e04],
        [1.9904137e03, 7.4643000e03, -2.0330000e02, 1.4543600e04],
        [1.9934137e03, 7.4427000e03, -1.9620000e02, 1.4572800e04],
        [1.9964137e03, 7.4222000e03, -1.9420000e02, 1.4604500e04],
        [1.9994137e03, 7.4029000e03, -1.9760000e02, 1.4639000e04],
        [2.0024137e03, 7.3889000e03, -2.0720000e02, 1.4667100e04],
        [2.0054137e03, 7.3748000e03, -2.1810000e02, 1.4695100e04],
        [2.0084137e03, 7.3519000e03, -2.2670000e02, 1.4732100e04],
        [2.0114137e03, 7.3253000e03, -2.3470000e02, 1.4775800e04],
        [2.0144137e03, 7.2946000e03, -2.4220000e02, 1.4826900e04],
        [2.0174137e03, 7.2698000e03, -2.6050000e02, 1.4885000e04],
        [2.0204137e03, 7.2477000e03, -2.8070000e02, 1.4942900e04],
        [2.0234137e03, 7.2341000e03, -2.9660000e02, 1.4987900e04],
    ]
)


def test_fetch_igrf14():
    "Check that the coefficient file can be fetched from Zenodo"
    fname = fetch_igrf14()
    assert os.path.exists(fname)


def test_load_igrf():
    "Check if things read have the right shapes and sizes and some values"
    years, g, h = load_igrf(fetch_igrf14())
    assert years.size == 27
    # assert years[0] == 1900
    # assert years[-1] == 2030
    npt.assert_allclose(years, np.arange(1900, 2031, 5))
    assert g.shape == (27, 14, 14)
    assert h.shape == (27, 14, 14)
    # Check that the 0,0 g is zero for all dates
    npt.assert_allclose(g[:, 0, 0], 0)
    # Check that all h for m=0 is zero for all dates
    npt.assert_allclose(h[:, :, 0], 0)
    # Check a few values against values copied from the file
    npt.assert_allclose(g[0, 1, 0], -31543)
    npt.assert_allclose(g[5, 5, 3], -28)
    npt.assert_allclose(g[24, 13, 13], -0.40)
    npt.assert_allclose(h[24, 13, 13], -0.60)
    npt.assert_allclose(h[12, 7, 1], -55)


def test_load_igrf_file_not_found():
    "Check if it fails when given a bad file name"
    with pytest.raises(IOError):
        load_igrf("bla.slkdjsldjh")


def test_interpolate_coefficients():
    "Check that calculating on or close to an epoch yields the right coefficients"
    years, g, h = load_igrf(fetch_igrf14())
    max_n = g.shape[1]
    for i, year in enumerate(years[1:], start=1):
        g_date, h_date = interpolate_coefficients(
            datetime.datetime(year - 1, month=12, day=31, hour=23, minute=59, second=0),
            years,
            g,
            h,
        )
        for n in range(max_n):
            for m in range(n):
                npt.assert_allclose(g_date[n, m], g[i, n, m], atol=0.001)
                npt.assert_allclose(h_date[n, m], h[i, n, m], atol=0.001)


@pytest.mark.parametrize(
    ("data", "month", "coordinates"),
    [
        (IGRF_SAO_PAULO, 1, (-43.70000, -23.50000, 700)),
        (IGRF_ULAANBAATAR, 6, (106.90000, 47.90000, 3000)),
    ],
    ids=["Sao Paulo", "Ulaanbaatar"],
)
def test_igrf_points(data, month, coordinates):
    "Check against NOAA calculations on individual points"
    years = data[:, 0].astype("int")
    for i, year in enumerate(years):
        date = datetime.datetime(year, month, day=1)
        field = IGRF14(date).predict(coordinates)
        npt.assert_allclose(np.ravel(field), (data[i, 1], data[i, 2], -data[i, 3]))
