"""
Forward modelling for point masses in Cartesian coordinates
"""
import numpy as np
from numba import jit


from ..constants import GRAVITATIONAL_CONST


def point_mass_gravity_cartesian(coordinates, points, masses, field, dtype="float64"):
    """
    Compute gravitational fields of a point mass on spherical coordinates.

    Parameters
    ----------
    coordinates : list or array
        List or array containing the Cartesian coordinates of the computation points
        `easting`, `northing`, `vertical` in meters.
    points : list or array
        List or array containing the Cartesian coordinates of the point masses
        `easting_p`, `northing_p`, `vertical_p` in meters.
    masses : list or array
        List or array containing the mass of each point mass in kg.
    field : str
        Gravitational field that wants to be computed.
        The available fields are:
        - Gravitational potential: ``potential``
        - Vertical acceleration: ``g_vertical``
    dtype : data-type (optional)
        Data type assigned to resulting gravitational field, and coordinates of point
        masses and computation points. Default to ``np.float64``.


    Returns
    -------
    result : array
        Gravitational field generated by the `point_mass` on the computation points
        defined in `coordinates`.
        The potential is given in SI units, the accelerations in mGal and the Marussi
        tensor components in Eotvos.
    """
    kernels = {"potential": kernel_potential, "g_vertical": kernel_g_vertical}
    if field not in kernels:
        raise ValueError("Gravity field {} not recognized".format(field))
    # Figure out the shape and size of the output array
    cast = np.broadcast(*coordinates[:3])
    result = np.zeros(cast.size, dtype=dtype)
    # Prepare arrays to be passed to the jitted functions
    easting, northing, vertical = (
        np.atleast_1d(i).ravel().astype(dtype) for i in coordinates[:3]
    )
    easting_p, northing_p, vertical_p = (
        np.atleast_1d(i).ravel().astype(dtype) for i in points[:3]
    )
    masses = np.atleast_1d(masses).astype(dtype).ravel()
    # Compute gravitational field
    jit_point_mass_gravity_cartesian(
        easting,
        northing,
        vertical,
        easting_p,
        northing_p,
        vertical_p,
        masses,
        result,
        kernels[field],
    )
    result *= GRAVITATIONAL_CONST
    # Convert to more convenient units
    if field == "g_vertical":
        result *= 1e5  # SI to mGal
    return result.reshape(cast.shape)


@jit(nopython=True)
def jit_point_mass_gravity_cartesian(
    easting, northing, vertical, easting_p, northing_p, vertical_p, masses, out, kernel
):
    """
    Compute gravity field of point masses on computation points.

    Parameters
    ----------
    easting, northing, vertical : 1d-arrays
        Cartesian coordinates of computation points in meters
    easting_p, northing_p, vertical_p : 1d-arrays
        Cartesian coordinates of point masses in meters
    masses : 1d-array
        Mass of each point mass in SI units.
    out : 1d-array
        Array where the gravitational field on each computation point will be appended.
        It must have the same size of ``easting``, ``northing`` and ``vertical``.
    kernel : func
        Kernel function that will be used to compute the gravity field on the
        computation points.
    """
    for l in range(easting.size):
        for m in range(easting_p.size):
            out[l] += masses[m] * kernel(
                easting[l],
                northing[l],
                vertical[l],
                easting_p[m],
                northing_p[m],
                vertical_p[m],
            )


@jit(nopython=True)
def kernel_potential(easting, northing, vertical, easting_p, northing_p, vertical_p):
    """
    Kernel function for potential gravity field
    """
    distance = np.sqrt(
        (easting - easting_p) ** 2
        + (northing - northing_p) ** 2
        + (vertical - vertical_p) ** 2
    )
    return 1 / distance


@jit(nopython=True)
def kernel_g_vertical(easting, northing, vertical, easting_p, northing_p, vertical_p):
    """
    Kernel function for vertical component of gravity gradient
    """
    distance_sq = (
        (easting - easting_p) ** 2
        + (northing - northing_p) ** 2
        + (vertical - vertical_p) ** 2
    )
    return (vertical - vertical_p) / distance_sq ** (3 / 2)
