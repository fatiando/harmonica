"""
Forward modelling for point masses
"""
import numpy as np
from numba import jit

from ..constants import GRAVITATIONAL_CONST


def point_mass_gravity(coordinates, points, masses, field, dtype="float64"):
    """
    Compute gravitational fields of a point mass on spherical coordinates.

    Parameters
    ----------
    coordinates : list or array
        List or array containing `longitude`, `latitude` and `radius` of computation
        points defined on a spherical geocentric coordinate system.
        Both `longitude` and `latitude` should be in degrees and `radius` in meters.
    points : list or array
        List or array containing the coordinates of the point masses `longitude_p`,
        `latitude_p`, `radius_p` defined on a spherical geocentric coordinate system.
        Both `longitude_p` and `latitude_p` should be in degrees and `radius` in meters.
    masses : list or array
        List or array containing the mass of each point mass in kg.
    field : str
        Gravitational field that wants to be computed.
        The available fields are:

        - Gravitational potential: ``potential``
        - Radial acceleration: ``g_r``
    dtype : data-type (optional)
        Data type assigned to resulting gravitational field, and coordinates of point
        masses and computation points. Default to ``np.float64``.


    Returns
    -------
    result : array
        Gravitational field generated by the `point_mass` on the computation points
        defined in `coordinates`.
        The potential is given in SI units, the accelerations in mGal and the Marussi
        tensor components in Eotvos.
    """
    kernels = {"potential": kernel_potential, "g_r": kernel_g_r}
    if field not in kernels:
        raise ValueError("Gravity field {} not recognized".format(field))
    # Figure out the shape and size of the output array
    cast = np.broadcast(*coordinates[:3])
    result = np.zeros(cast.size, dtype=dtype)
    # Prepare arrays to be passed to the jitted functions
    longitude, latitude, radius = (
        np.atleast_1d(i).ravel().astype(dtype) for i in coordinates[:3]
    )
    longitude_p, latitude_p, radius_p = (
        np.atleast_1d(i).ravel().astype(dtype) for i in points[:3]
    )
    masses = np.atleast_1d(masses).astype(dtype).ravel()
    # Compute gravitational field
    jit_point_mass_gravity(
        longitude,
        latitude,
        radius,
        longitude_p,
        latitude_p,
        radius_p,
        masses,
        result,
        kernels[field],
    )
    result *= GRAVITATIONAL_CONST
    # Convert to more convenient units
    if field == "g_r":
        result *= 1e5  # SI to mGal
    return result.reshape(cast.shape)


@jit(nopython=True)
def jit_point_mass_gravity(
    longitude, latitude, radius, longitude_p, latitude_p, radius_p, masses, out, kernel
):  # pylint: disable=invalid-name
    """
    Compute gravity field of point masses on computation points.

    Parameters
    ----------
    longitude, latitude, radius : 1d-arrays
        Coordinates of computation points in spherical geocentric coordinate system.
    longitude_p, latitude_p, radius_p : 1d-arrays
        Coordinates of point masses in spherical geocentric coordinate system.
    masses : 1d-array
        Mass of each point mass in SI units.
    out : 1d-array
        Array where the gravitational field on each computation point will be appended.
        It must have the same size of ``longitude``, ``latitude`` and ``radius``.
    kernel : func
        Kernel function that will be used to compute the gravity field on the
        computation points.
    """
    # Compute quantities related to computation point
    longitude = np.radians(longitude)
    latitude = np.radians(latitude)
    cosphi = np.cos(latitude)
    sinphi = np.sin(latitude)
    # Compute quantities related to point masses
    longitude_p = np.radians(longitude_p)
    latitude_p = np.radians(latitude_p)
    cosphi_p = np.cos(latitude_p)
    sinphi_p = np.sin(latitude_p)
    # Compute gravity field
    for l in range(longitude.size):
        for m in range(longitude_p.size):
            out[l] += masses[m] * kernel(
                longitude[l],
                cosphi[l],
                sinphi[l],
                radius[l],
                longitude_p[m],
                cosphi_p[m],
                sinphi_p[m],
                radius_p[m],
            )


@jit(nopython=True)
def kernel_potential(
    longitude, cosphi, sinphi, radius, longitude_p, cosphi_p, sinphi_p, radius_p
):
    """
    Kernel function for potential gravity field
    """
    coslambda = np.cos(longitude_p - longitude)
    cospsi = sinphi_p * sinphi + cosphi_p * cosphi * coslambda
    distance_sq = (radius - radius_p) ** 2 + 2 * radius * radius_p * (1 - cospsi)
    return 1 / np.sqrt(distance_sq)


@jit(nopython=True)
def kernel_g_r(
    longitude, cosphi, sinphi, radius, longitude_p, cosphi_p, sinphi_p, radius_p
):
    """
    Kernel function for radial component of gravity gradient
    """
    coslambda = np.cos(longitude_p - longitude)
    cospsi = sinphi_p * sinphi + cosphi_p * cosphi * coslambda
    distance_sq = (radius - radius_p) ** 2 + 2 * radius * radius_p * (1 - cospsi)
    delta_z = radius_p * cospsi - radius
    return delta_z / distance_sq ** (3 / 2)
