"""
Forward modelling for point masses
"""
import numpy as np
from numba import jit

from ..constants import GRAVITATIONAL_CONST


def point_mass_gravity(coordinates, point_mass, mass, field, dtype="float64"):
    """
    Compute gravitational fields of a point mass on spherical coordinates.

    Parameters
    ----------
    coordinates : list or array
        List or array containing `longitude`, `latitude` and `radius` of computation
        points defined on a spherical geocentric coordinate system.
        Both `longitude` and `latitude` should be in degrees and `radius` in meters.
    point_mass : list or array
        Coordinates of the point mass: [`longitude`, `latitude`, `radius`] defined on
        a spherical geocentric coordinate system.
        Both `longitude` and `latitude` should be in degrees and `radius` in meters.
    mass : float
        Mass of the point mass in kg.
    field : str
        Gravitational field that wants to be computed.
        The available fields are:

        - Gravitational potential: ``potential``
        - Accelerations or gradient components: ``gx``, ``gy``, ``gz``
        - Maurssi tensor components: ``gxx``, ``gxy``, ``gxz``, ``gyy``, ``gyz``,
          ``gzz``

    Returns
    -------
    gravitational_field : array
        Gravitational field generated by the `point_mass` on the computation points
        defined in `coordinates`.
    """
    kernels = {
        "potential": kernel_potential,
        "gx": kernel_gx,
        "gy": kernel_gy,
        "gz": kernel_gz,
        "gxx": kernel_gxx,
        "gxy": kernel_gxy,
        "gxz": kernel_gxz,
        "gyy": kernel_gyy,
        "gyz": kernel_gyz,
        "gzz": kernel_gzz,
    }
    if field not in kernels:
        raise ValueError("Gravity field {} not recognized".format(field))
    # Figure out the shape and size of the output array
    cast = np.broadcast(*coordinates[:3])
    result = np.zeros(cast.size, dtype=dtype)
    longitude, latitude, radius = (i.ravel() for i in coordinates[:3])
    jit_point_mass_gravity(
        longitude, latitude, radius, point_mass, kernels[field], result
    )
    result *= GRAVITATIONAL_CONST * mass
    # Convert to more convenient units
    if field in ("gx", "gy", "gz"):
        result *= 1e5  # SI to mGal
    if field in ("gxx", "gxy", "gxz", "gyy", "gyz", "gzz"):
        result *= 1e9  # SI to Eotvos
    return result.reshape(cast.shape)


@jit(nopython=True)
def jit_point_mass_gravity(longitude, latitude, radius, point_mass, kernel, out):
    """
    """
    longitude_p, latitude_p, radius_p = point_mass[:]
    longitude_p, latitude_p = np.radians(longitude_p), np.radians(latitude_p)
    cosphi_p = np.cos(latitude_p)
    sinphi_p = np.sin(latitude_p)
    radius_p_sq = radius_p ** 2
    cosphi = np.cos(np.radians(latitude))
    sinphi = np.sin(np.radians(latitude))
    longitude_radians = np.radians(longitude)
    for l in range(out.size):
        out[l] += kernel(
            longitude_radians[l],
            cosphi[l],
            sinphi[l],
            radius[l],
            longitude_p,
            cosphi_p,
            sinphi_p,
            radius_p,
            radius_p_sq,
        )


@jit(nopython=True)
def kernel_potential(
    longitude,
    cosphi,
    sinphi,
    radius,
    longitude_p,
    cosphi_p,
    sinphi_p,
    radius_p,
    radius_p_sq,
):
    coslambda = np.cos(longitude_p - longitude)
    cospsi = sinphi_p * sinphi + cosphi_p * cosphi * coslambda
    distance_sq = radius ** 2 + radius_p_sq - 2 * radius * radius_p * cospsi
    return 1 / np.sqrt(distance_sq)


@jit(nopython=True)
def kernel_gx(
    longitude,
    cosphi,
    sinphi,
    radius,
    longitude_p,
    cosphi_p,
    sinphi_p,
    radius_p,
    radius_p_sq,
):
    coslambda = np.cos(longitude_p - longitude)
    cospsi = sinphi_p * sinphi + cosphi_p * cosphi * coslambda
    distance_sq = radius ** 2 + radius_p_sq - 2 * radius * radius_p * cospsi
    delta_x = radius_p * (cosphi * sinphi_p - sinphi * cosphi_p * coslambda)
    return delta_x / distance_sq ** (3 / 2)


@jit(nopython=True)
def kernel_gy(
    longitude,
    cosphi,
    sinphi,
    radius,
    longitude_p,
    cosphi_p,
    sinphi_p,
    radius_p,
    radius_p_sq,
):
    coslambda = np.cos(longitude_p - longitude)
    sinlambda = np.sin(longitude_p - longitude)
    cospsi = sinphi_p * sinphi + cosphi_p * cosphi * coslambda
    distance_sq = radius ** 2 + radius_p_sq - 2 * radius * radius_p * cospsi
    delta_y = radius_p * cosphi_p * sinlambda
    return delta_y / distance_sq ** (3 / 2)


@jit(nopython=True)
def kernel_gz(
    longitude,
    cosphi,
    sinphi,
    radius,
    longitude_p,
    cosphi_p,
    sinphi_p,
    radius_p,
    radius_p_sq,
):
    coslambda = np.cos(longitude_p - longitude)
    cospsi = sinphi_p * sinphi + cosphi_p * cosphi * coslambda
    distance_sq = radius ** 2 + radius_p_sq - 2 * radius * radius_p * cospsi
    delta_z = radius_p * cospsi - radius
    return delta_z / distance_sq ** (3 / 2)


@jit(nopython=True)
def kernel_gxx(
    longitude,
    cosphi,
    sinphi,
    radius,
    longitude_p,
    cosphi_p,
    sinphi_p,
    radius_p,
    radius_p_sq,
):
    coslambda = np.cos(longitude_p - longitude)
    cospsi = sinphi_p * sinphi + cosphi_p * cosphi * coslambda
    distance_sq = radius ** 2 + radius_p_sq - 2 * radius * radius_p * cospsi
    delta_x = radius_p * (cosphi * sinphi_p - sinphi * cosphi_p * coslambda)
    return (3 * delta_x ** 2 - distance_sq) / distance_sq ** (5 / 2)


@jit(nopython=True)
def kernel_gxy(
    longitude,
    cosphi,
    sinphi,
    radius,
    longitude_p,
    cosphi_p,
    sinphi_p,
    radius_p,
    radius_p_sq,
):
    coslambda = np.cos(longitude_p - longitude)
    sinlambda = np.sin(longitude_p - longitude)
    cospsi = sinphi_p * sinphi + cosphi_p * cosphi * coslambda
    distance_sq = radius ** 2 + radius_p_sq - 2 * radius * radius_p * cospsi
    delta_x = radius_p * (cosphi * sinphi_p - sinphi * cosphi_p * coslambda)
    delta_y = radius_p * cosphi_p * sinlambda
    return 3 * delta_x * delta_y / distance_sq ** (5 / 2)


@jit(nopython=True)
def kernel_gxz(
    longitude,
    cosphi,
    sinphi,
    radius,
    longitude_p,
    cosphi_p,
    sinphi_p,
    radius_p,
    radius_p_sq,
):
    coslambda = np.cos(longitude_p - longitude)
    cospsi = sinphi_p * sinphi + cosphi_p * cosphi * coslambda
    distance_sq = radius ** 2 + radius_p_sq - 2 * radius * radius_p * cospsi
    delta_x = radius_p * (cosphi * sinphi_p - sinphi * cosphi_p * coslambda)
    delta_z = radius_p * cospsi - radius
    return 3 * delta_x * delta_z / distance_sq ** (5 / 2)


@jit(nopython=True)
def kernel_gyy(
    longitude,
    cosphi,
    sinphi,
    radius,
    longitude_p,
    cosphi_p,
    sinphi_p,
    radius_p,
    radius_p_sq,
):
    coslambda = np.cos(longitude_p - longitude)
    sinlambda = np.sin(longitude_p - longitude)
    cospsi = sinphi_p * sinphi + cosphi_p * cosphi * coslambda
    distance_sq = radius ** 2 + radius_p_sq - 2 * radius * radius_p * cospsi
    delta_y = radius_p * cosphi_p * sinlambda
    return (3 * delta_y ** 2 - distance_sq) / distance_sq ** (5 / 2)


@jit(nopython=True)
def kernel_gyz(
    longitude,
    cosphi,
    sinphi,
    radius,
    longitude_p,
    cosphi_p,
    sinphi_p,
    radius_p,
    radius_p_sq,
):
    coslambda = np.cos(longitude_p - longitude)
    sinlambda = np.sin(longitude_p - longitude)
    cospsi = sinphi_p * sinphi + cosphi_p * cosphi * coslambda
    distance_sq = radius ** 2 + radius_p_sq - 2 * radius * radius_p * cospsi
    delta_y = radius_p * cosphi_p * sinlambda
    delta_z = radius_p * cospsi - radius
    return 3 * delta_y * delta_z / distance_sq ** (5 / 2)


@jit(nopython=True)
def kernel_gzz(
    longitude,
    cosphi,
    sinphi,
    radius,
    longitude_p,
    cosphi_p,
    sinphi_p,
    radius_p,
    radius_p_sq,
):
    coslambda = np.cos(longitude_p - longitude)
    cospsi = sinphi_p * sinphi + cosphi_p * cosphi * coslambda
    distance_sq = radius ** 2 + radius_p_sq - 2 * radius * radius_p * cospsi
    delta_z = radius_p * cospsi - radius
    return (3 * delta_z ** 2 - distance_sq) / distance_sq ** (5 / 2)
